# M9.8.25: Fix Sync to Use Per-Server Data Paths

**Priority:** HIGH (Bug Fix)
**Dependencies:** M9.8.23 (Per-Server Path Override), M9.8.24 (Restore UI)
**Created:** 2026-01-14
**Status:** PLANNED

---

## Problem Statement

The server sync feature has a critical bug: it checks for data existence using a **hardcoded path** instead of respecting:
1. Agent's `server_data_path` configuration (M9.8.21)
2. Per-server `server_data_path` overrides (M9.8.23)

Additionally, the restore operation sets `data_exists=1` **blindly** without verifying the filesystem.

### Current Behavior

**Sync (AgentConnection.ts:1959-1965):**
```typescript
const dataCheckResponse = await this.sendMessageWithReply({
  subject: 'server.checkdata',
  data: {
    servers: serverNames,
    dataPath: '/var/lib/zedops/servers',  // HARDCODED! ❌
  },
}, 10000);
```

**Restore (agents.ts:1883):**
```typescript
await c.env.DB.prepare(
  `UPDATE servers SET status = 'missing', deleted_at = NULL, data_exists = 1, updated_at = ? WHERE id = ?`
)
  .bind(now, serverId)
  .run();
// Sets data_exists=1 without checking filesystem! ❌
```

### Impact

**For servers with custom data paths:**
- Sync checks `/var/lib/zedops/servers/{name}` (wrong location)
- `data_exists` remains 0 even if data exists at custom path
- Start button doesn't appear (requires `status='missing' && data_exists=1`)

**For restored servers:**
- `data_exists=1` set without verification
- Start button appears even if data was manually deleted
- User clicks Start → container creation fails

---

## Solution Design

### Option A: Fix Sync to Use Correct Paths

**Goal:** Sync checks the correct path for each server

**Approach 1: Per-Server Path Lookup (Recommended)**
```typescript
// For each server, determine its data path
for (const server of servers) {
  const dataPath = server.server_data_path || agent.server_data_path;

  // Check data existence for this specific path
  const dataCheckResponse = await this.sendMessageWithReply({
    subject: 'server.checkdata',
    data: {
      servers: [server.name],
      dataPath: dataPath,
    },
  }, 10000);

  // Update data_exists based on actual result
  newDataExists = dataCheckResponse.data.statuses[0].dataExists;
}
```

**Pros:**
- Respects per-server path overrides
- Accurate data existence checking
- Simple implementation

**Cons:**
- Multiple sequential messages (slower for many servers)
- Could optimize with batching by unique paths

**Approach 2: Batch by Path (Optimized)**
```typescript
// Group servers by data path
const serversByPath = new Map();
for (const server of servers) {
  const dataPath = server.server_data_path || agent.server_data_path;
  if (!serversByPath.has(dataPath)) {
    serversByPath.set(dataPath, []);
  }
  serversByPath.get(dataPath).push(server);
}

// Check each path group
for (const [dataPath, pathServers] of serversByPath) {
  const serverNames = pathServers.map(s => s.name);
  const dataCheckResponse = await this.sendMessageWithReply({
    subject: 'server.checkdata',
    data: {
      servers: serverNames,
      dataPath: dataPath,
    },
  }, 10000);

  // Update each server's data_exists
  // ...
}
```

**Pros:**
- Batches requests by path (more efficient)
- Still accurate

**Cons:**
- More complex implementation

---

### Option C: Make Restore Verify Data Exists

**Goal:** Restore checks filesystem before setting `data_exists=1`

**Approach: Trigger Targeted Sync**
```typescript
// After restoring server
await c.env.DB.prepare(
  `UPDATE servers SET status = 'missing', deleted_at = NULL, updated_at = ? WHERE id = ?`
)
  .bind(now, serverId)
  .run();

// Determine data path for this server
const dataPath = server.server_data_path || agent.server_data_path;

// Check if data actually exists
const dataCheckResponse = await stub.fetch('http://internal/check-data', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    serverName: server.name,
    dataPath: dataPath,
  }),
});

const checkResult = await dataCheckResponse.json();

// Update data_exists based on actual filesystem check
await c.env.DB.prepare(
  `UPDATE servers SET data_exists = ? WHERE id = ?`
)
  .bind(checkResult.dataExists ? 1 : 0, serverId)
  .run();
```

**Pros:**
- Restore is accurate (no blind assumption)
- Better UX (Start button only appears if data exists)

**Cons:**
- Additional network call during restore
- Need to handle agent offline scenario

---

## Implementation Plan

### Phase 1: Fix Sync to Use Per-Server Paths

**Tasks:**
1. Update `syncServers()` in AgentConnection.ts:
   - Query agent config to get default `server_data_path`
   - For each server, determine: `server.server_data_path || agent.server_data_path`
   - Group servers by unique data path (optimization)
   - Call `server.checkdata` for each path group
   - Update `data_exists` based on actual results

2. Test sync with:
   - Servers using agent default path
   - Servers with custom per-server paths
   - Mixed scenario (some custom, some default)

**Files to Modify:**
- `manager/src/durable-objects/AgentConnection.ts` (syncServers function, ~line 1922)

---

### Phase 2: Make Restore Verify Data Exists

**Tasks:**
1. Update restore endpoint in agents.ts:
   - Don't set `data_exists=1` immediately
   - Get Durable Object stub
   - Call agent to check data existence
   - Update `data_exists` based on actual result

2. Add helper endpoint to AgentConnection DO (optional):
   - `POST /internal/check-data` for single-server checks
   - Or reuse sync logic with single server

3. Test restore with:
   - Data exists at default path
   - Data exists at custom path
   - Data doesn't exist (purged manually)

**Files to Modify:**
- `manager/src/routes/agents.ts` (restore endpoint, ~line 1852)
- `manager/src/durable-objects/AgentConnection.ts` (optional helper endpoint)

---

### Phase 3: Testing & Verification

**Test Scenarios:**

1. **Sync with custom paths:**
   - Create server with custom data path
   - Manually delete container
   - Click Sync
   - Verify `data_exists` set correctly

2. **Restore with data:**
   - Soft delete server (data preserved)
   - Restore server
   - Verify Start button appears
   - Click Start → success

3. **Restore without data:**
   - Soft delete server
   - Manually delete data directories
   - Restore server
   - Verify Start button does NOT appear (or shows Purge only)

4. **Agent offline during restore:**
   - Soft delete server
   - Stop agent
   - Try to restore
   - Verify appropriate error message

---

## Success Criteria

- [ ] Sync checks correct data path for each server (default or custom)
- [ ] Restore verifies data existence before setting flag
- [ ] Start button only appears when data actually exists
- [ ] Works with agent default paths
- [ ] Works with per-server custom paths
- [ ] Handles agent offline gracefully
- [ ] No performance regression (sync still fast for many servers)

---

## Notes

**Why This Matters:**
- M9.8.23 added per-server path overrides
- Without this fix, sync is broken for custom paths
- Restore UX is misleading (shows Start button when data doesn't exist)

**Related Work:**
- M9.8.21: Agent configuration storage
- M9.8.22: Agent config display tab
- M9.8.23: Per-server data path override
- M9.8.24: Restore UI (discovered this bug during testing)

**Technical Debt:**
This bug existed before M9.8.23 (hardcoded path in sync), but became critical after adding per-server path overrides.
