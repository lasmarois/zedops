# Findings: Milestone 1 - Agent Connection

**Purpose:** Store research discoveries, design decisions, and architectural notes discovered during implementation.

**Last Updated:** 2026-01-10

---

## Architecture Research

### Cloudflare Workers + Durable Objects

**Key Learnings:**
- Durable Objects are single-threaded (one instance per agent = one connection per DO)
- WebSocket connections in Durable Objects are persistent (survive across requests)
- Workers can route to specific Durable Object instances by ID
- D1 can be queried from both Workers and Durable Objects

**Implications:**
- Each agent gets its own Durable Object instance (keyed by agent ID)
- Agent connection state lives in Durable Object memory (not D1)
- Manager Worker routes `/ws` to Durable Object using agent token as ID

**References:**
- [Durable Objects WebSocket Docs](https://developers.cloudflare.com/durable-objects/examples/websocket-server/)

---

### NATS Message Protocol Design

**Message Structure:**
```typescript
interface Message {
  subject: string;      // e.g., "agent.register", "server.start"
  reply?: string;       // Reply inbox for request/reply pattern
  data: any;            // Payload (JSON-serializable)
  timestamp?: number;   // Unix timestamp
}
```

**Subject Namespaces:**
```
agent.*                 # Agent-initiated messages
  agent.register        # Agent registration with ephemeral token
  agent.heartbeat       # Agent heartbeat (every 30s)
  agent.disconnect      # Agent graceful disconnect

inbox.*                 # Reply subjects (internal)
  inbox.{uuid}          # One-time reply channel for request/reply
```

**Request/Reply Pattern:**
```typescript
// Agent sends request:
{
  subject: "agent.register",
  reply: "inbox.abc-123",
  data: { token: "ephemeral-token-here", name: "agent-1" }
}

// Manager sends reply:
{
  subject: "inbox.abc-123",
  data: { success: true, token: "permanent-token-here" }
}
```

**Design Decision:** Use simple JSON over WebSocket instead of actual NATS server (zero external dependencies, works on Cloudflare).

---

### Token Flow Design

**Ephemeral Token:**
- Generated by manager admin endpoint: `POST /api/admin/tokens`
- JWT with 1-hour expiry
- Payload: `{ type: "ephemeral", exp: <timestamp> }`
- Used ONCE for agent registration
- Cannot be reused after registration

**Permanent Token:**
- Generated by manager after successful registration
- JWT with NO expiry
- Payload: `{ type: "permanent", agentId: "<uuid>" }`
- Stored on agent filesystem: `~/.zedops-agent/token`
- Used for all future connections (reconnection)

**Security Notes:**
- Ephemeral token prevents unauthorized agent registration
- Permanent token identifies agent on reconnect
- Tokens are JWTs (can be validated without database lookup)
- Token secret stored in Wrangler environment variable

**Implementation:**
```typescript
// Generate ephemeral token (manager)
const ephemeralToken = await createJWT({
  type: 'ephemeral',
  exp: Date.now() + 3600000 // 1 hour
}, env.TOKEN_SECRET);

// Generate permanent token (manager)
const permanentToken = await createJWT({
  type: 'permanent',
  agentId: agentId
}, env.TOKEN_SECRET);
```

---

### Agent Reconnection Strategy

**Exponential Backoff:**
```
Attempt 1: Wait 1s
Attempt 2: Wait 2s
Attempt 3: Wait 4s
Attempt 4: Wait 8s
Attempt 5: Wait 16s
...
Max Wait: 60s (cap)
Max Attempts: Unlimited (agent keeps trying forever)
```

**Connection States:**
```
DISCONNECTED → CONNECTING → CONNECTED → DISCONNECTED
       ↑                          ↓
       └──────────(retry)─────────┘
```

**Heartbeat Logic:**
- Agent sends `agent.heartbeat` every 30 seconds
- Manager updates `last_seen` timestamp in memory
- If no heartbeat for 60 seconds → agent considered offline
- Durable Object tracks this (no D1 write on every heartbeat)

**Go Implementation:**
```go
type ConnectionState int

const (
    Disconnected ConnectionState = iota
    Connecting
    Connected
)

func (a *Agent) reconnectLoop() {
    backoff := 1 * time.Second
    maxBackoff := 60 * time.Second

    for {
        if a.state == Disconnected {
            a.state = Connecting
            err := a.connect()
            if err == nil {
                a.state = Connected
                backoff = 1 * time.Second
                a.startHeartbeat()
            } else {
                time.Sleep(backoff)
                backoff = min(backoff*2, maxBackoff)
            }
        }
        time.Sleep(1 * time.Second)
    }
}
```

---

### D1 Database Schema

**Agents Table:**
```sql
CREATE TABLE agents (
  id TEXT PRIMARY KEY,              -- UUID
  name TEXT NOT NULL,               -- User-provided agent name
  token_hash TEXT NOT NULL,         -- SHA-256 hash of permanent token
  status TEXT DEFAULT 'offline',    -- 'online' | 'offline'
  last_seen INTEGER,                -- Unix timestamp
  created_at INTEGER NOT NULL,      -- Unix timestamp
  metadata TEXT                     -- JSON: OS, version, etc.
);

CREATE INDEX idx_agents_status ON agents(status);
CREATE INDEX idx_agents_last_seen ON agents(last_seen);
```

**Why token_hash instead of token:**
- Security: Never store raw tokens in database
- Validation: Hash incoming token and compare with stored hash
- Same pattern as password hashing

**Status Field:**
- Updated when agent connects/disconnects
- Queried by `/api/agents` endpoint
- NOT updated on every heartbeat (only on connect/disconnect)

---

### Hardcoded Admin Auth (MVP)

**Environment Variable:**
```
ADMIN_PASSWORD=super-secret-password-here
```

**Auth Flow:**
1. User enters password in UI
2. UI sends `POST /api/auth/login` with password
3. Manager validates password against `env.ADMIN_PASSWORD`
4. If valid, return JWT (admin session token)
5. UI stores JWT in localStorage
6. All API requests include JWT in `Authorization: Bearer <token>` header

**JWT Payload:**
```json
{
  "type": "admin",
  "exp": 1234567890  // 7-day expiry
}
```

**Security:**
- Password never stored (compared directly)
- JWT rotates every 7 days (requires re-login)
- HTTPS required in production (Cloudflare provides this)

**Migration to Proper Auth (Milestone 6):**
- Add users table
- Replace hardcoded password with email/password
- Add role field (admin, operator, viewer)
- Keep JWT structure compatible

---

## Technology Choices

### Frontend: Vite + React + TypeScript

**Why Vite:**
- Fast dev server (native ESM, no bundling)
- Modern tooling (out-of-the-box TypeScript)
- Official React + TS template available

**Setup Command:**
```bash
npm create vite@latest frontend -- --template react-ts
```

**Dependencies to Add:**
```json
{
  "@tanstack/react-query": "^5.0.0",  // Server state
  "zustand": "^4.0.0",                // Client state
  "react-router-dom": "^6.0.0"        // Routing (future)
}
```

**Shadcn UI:**
- Copy components manually (not a package)
- Tailwind CSS based
- Accessible, customizable

---

### Manager: Hono + TypeScript

**Why Hono:**
- Lightweight (< 10KB)
- Fast routing (optimized for Workers)
- Express-like API (familiar)
- Native TypeScript support

**Setup:**
```bash
npm create cloudflare@latest manager
# Select: "Hello World" Worker → TypeScript → Git
```

**Dependencies:**
```json
{
  "hono": "^4.0.0",
  "jose": "^5.0.0"  // JWT library (works in Workers)
}
```

**wrangler.toml Structure:**
```toml
name = "zedops"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[assets]
directory = "../frontend/dist"
not_found_handling = "single-page-application"

[[durable_objects.bindings]]
name = "AGENT_CONNECTION"
class_name = "AgentConnection"

[[d1_databases]]
binding = "DB"
database_name = "zedops-db"
database_id = "<created-via-wrangler>"

[vars]
TOKEN_SECRET = "dev-secret-change-in-production"
ADMIN_PASSWORD = "admin"
```

---

### Agent: Go + gorilla/websocket

**Why Go:**
- See TD-003 in TECH_DECISIONS.md
- Single binary (easy distribution)
- Strong concurrency (goroutines for heartbeat, reconnect)

**Dependencies:**
```go
// go.mod
module github.com/lasmarois/zedops/agent

go 1.21

require (
    github.com/google/uuid v1.5.0
    github.com/gorilla/websocket v1.5.1
)
```

**Project Structure:**
```
agent/
├── main.go           // Entrypoint, CLI flags
├── agent.go          // Agent struct, connection logic
├── message.go        // Message struct, send/receive
├── token.go          // Token storage/retrieval
└── reconnect.go      // Reconnection logic
```

---

## Design Questions & Answers

### Q: How does manager know which Durable Object instance to route to?

**A:** Use agent ID (from permanent token) as Durable Object ID.

**Flow:**
1. Agent connects to `/ws` with permanent token in query param or header
2. Manager validates token, extracts `agentId`
3. Manager gets Durable Object stub: `env.AGENT_CONNECTION.get(env.AGENT_CONNECTION.idFromName(agentId))`
4. Manager forwards WebSocket to that specific Durable Object
5. All messages from this agent go to the same Durable Object instance

**Why this works:**
- `idFromName(agentId)` is deterministic (same agentId → same DO instance)
- DO instance persists state (connection, last_seen, etc.)
- Multiple agents = multiple DO instances (scales automatically)

---

### Q: How to handle agent sending messages before registration?

**A:** Reject all messages except `agent.register` if agent not registered.

**Implementation:**
```typescript
// In Durable Object
handleMessage(msg: Message) {
  if (!this.registered && msg.subject !== 'agent.register') {
    this.send({
      subject: msg.reply || 'error',
      data: { error: 'Not registered. Send agent.register first.' }
    });
    return;
  }

  // Route message by subject...
}
```

---

### Q: What happens if agent reconnects with same permanent token?

**A:** Manager treats it as normal reconnection (not new registration).

**Flow:**
1. Agent sends permanent token in WebSocket connection
2. Manager validates token, extracts `agentId`
3. Manager routes to Durable Object (same instance as before)
4. Durable Object sees connection, marks agent as `online`
5. Agent does NOT send `agent.register` (already registered)
6. Agent starts sending `agent.heartbeat` immediately

**State Recovery:**
- Durable Object state persists (agent metadata still in memory)
- D1 record exists (agent already in database)
- No need to re-register

---

### Q: How to test Durable Objects locally?

**A:** Use `wrangler dev --local` with local Durable Objects.

**Commands:**
```bash
# Start dev server with local DO
cd manager
wrangler dev --local

# D1 database (local SQLite)
wrangler d1 execute zedops-db --local --file=schema.sql

# Test WebSocket
npx wscat -c ws://localhost:8787/ws?token=<permanent-token>
```

**Limitations:**
- Local DO state resets on restart (not persisted)
- No distributed coordination (single machine)
- Good enough for development

---

## Discovered Issues & Solutions

### Issue 1: WebSocket URL in Agent

**Problem:** Agent needs to know manager URL (wss://zedops.workers.dev/ws)

**Solution:** Make it configurable via CLI flag or env var.

```go
// CLI flag
var managerURL = flag.String("manager", "wss://zedops.workers.dev/ws", "Manager WebSocket URL")

// Or environment variable
managerURL := os.Getenv("ZEDOPS_MANAGER_URL")
if managerURL == "" {
    managerURL = "wss://zedops.workers.dev/ws"
}
```

**For Development:**
```bash
# Local manager
go run main.go --manager ws://localhost:8787/ws --token <ephemeral>

# Production manager
go run main.go --manager wss://zedops.workers.dev/ws --token <ephemeral>
```

---

### Issue 2: Token in WebSocket Connection

**Problem:** How to send token when opening WebSocket?

**Options:**
1. Query parameter: `ws://manager/ws?token=<token>`
2. HTTP header: `Authorization: Bearer <token>` (WebSocket supports this)
3. First message: Send token as first WebSocket message

**Decision:** Use query parameter (simplest, works everywhere).

```typescript
// Manager: Extract token from URL
const url = new URL(request.url);
const token = url.searchParams.get('token');
if (!token) {
  return new Response('Missing token', { status: 401 });
}
```

```go
// Agent: Include token in URL
conn, _, err := websocket.DefaultDialer.Dial(
  fmt.Sprintf("%s?token=%s", managerURL, token),
  nil,
)
```

---

## Open Questions

### Q: Should agent send OS/version metadata during registration?

**Current Plan:** Yes, include in `agent.register` data.

```typescript
// Agent sends
{
  subject: "agent.register",
  reply: "inbox.abc",
  data: {
    token: "ephemeral-token",
    name: "friend-a-pc",
    metadata: {
      os: "linux",
      arch: "amd64",
      version: "1.0.0"
    }
  }
}
```

**Benefit:** Useful for debugging, shows in UI, helps with compatibility checks.

---

### Q: How to handle concurrent agent registrations with same ephemeral token?

**Current Plan:** First one wins, subsequent attempts fail.

**Implementation:** Mark ephemeral token as "used" after first successful registration (store in D1 or KV).

**Decision:** Skip this for MVP (assume user doesn't spam registration). Can add in future if needed.

---

## References

- [Cloudflare Durable Objects WebSocket Example](https://developers.cloudflare.com/durable-objects/examples/websocket-server/)
- [gorilla/websocket Documentation](https://pkg.go.dev/github.com/gorilla/websocket)
- [Hono Documentation](https://hono.dev/)
- [Jose (JWT) for Workers](https://github.com/panva/jose)
- [Vite React TypeScript Template](https://vitejs.dev/guide/#scaffolding-your-first-vite-project)
